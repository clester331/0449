# Lecture 16

## How Programs Are Made

### Compilation: Simple Overview - Step 1

* The compiler takes source code (*.c files) and translates them into machine code
* This file is called an "object file" and is just potentially one part of the project
* The machine code is not quite an executable
  * The object file is JUST representing the code for that particular source file

### Compilation: Simple Overview - Step 2

* You may have multiple files that reference each other
* You break your project up into pieces similarly to your java programs
* The compiler treats them independently

### Compilation: Simple Overview - Step 3

* Then, each piece is merged together to form the executable
* This process is done by a linker and is called linking

### Compiler

* Input: Higher-level language code (e.g. C, Java(
* Output: Assembly language code (e.g. x86, ARM, MIPS)
* First there's a preprocessor step to handle #directives
* Compiler optimizations
  * "Level" of optimization specified by capital 'O' flag
 
### The Need for a Linker

* A **compiler** converts source code into machine code
* A **linked** merges pieces of machine code into an executable

* Why have a seperate tool for creating executables?
  * Mixing different languages together
  * Let's us break large programs up into smaller pieces
  * Those small pieces can come from others. Code reuse

### Inside the Box

* To understand what linkers do we need to see what an executable is made out of
* A linux executable is defined by the **executable and linkable format** (ELF) standard
  * Used for *.o files
  * And executables
  * and *.so (shared objects)

### Object File Format

* Object file header: size and position of the other pieces of the objects file
* Text segment: The machine code
* Data segment: data in the source file (binary)
* Relocation table: Identifies lines of code that need to be handled
* Symbol table: list of this file's labels and data that can be referenced
* Debugging information

#### Object File Information Tables

* Symbol Table holds list of "items" that may be used by other files
  * Non-local lables (function names for call)
  * Static data (Variables & literals that might be accesed across files) 
* Relocation Table holds list of "items" tat this file needs the address of later
  * Any lable or piece of static data referenced in an instruction in this file 
* Each file has its own symbol and relocation tables

![image](https://github.com/clester331/0449/assets/122314614/90bbc876-9351-4c5a-a750-538b4975c77d)

### What is in the ELF

* THe remianing fields indicate where certain sections start
* An ELF executable containse these sections:
  * Segment headers
  * The symbol table

* Symbols can consist of
  * Functions
  * Global variables
  * Special sections

### Static

* The static keyword forces any symbol to be local to the current file. That is, it can not be referenced by any outside function
* This is because the symbol will not be included in the symbol table
* The linker will not be able to see it
* This is useful for avoiding **name collisions**, when two functions have the same name 
