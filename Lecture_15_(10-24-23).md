# Lecture 15

## Buffer Overflow

### Memory Review

* Stack
  * Local variables
* Heap
  * Dynamically allocated as needed
  * malloc(), calloc(), new()
* Statically allocated data
  * Red/write: global variables
  * Read-only: string literals
* Code/instructions
  * Executable machine instructions
  * Read only
 
### x86-64 Linux Memory Layout

* Stack
  * Runtime stack (8MB limit)
  * e.g., local variables
* Heap
  * Dynamic allocated as needed
  * When call malloc(), new()
* Data
  * Statically allocated data
  * e.g., global/static vars, string constatns
* Text / Shared Libraries
  * Executable machine instructions
  * Read-only
 
![image](https://github.com/clester331/0449/assets/122314614/0f97afb9-d1b4-44b7-8c13-d11cb4c180ff)

### x86-64 Stack Frame

* Caller's Stack Frame
  * Arguments (if > 6 args) for this call

* Current/Calle Stack Frame
  * Return address
    * Pushed by call instruction
  * Old frame pointer (optional)
  * Saved register contect (when reusing registers)
  * Local Variables (If can't be kept in register)
  * "Argument build" area (If calle needs to call another function - parameters for function about to call, if needed)

### Buffer Overflow

* Traditional Linux memory layout provides opportunities for malicious programs
  * Stack grows "backwards" in memory
  * Data and instructions both stored in the same memory
* Recall that C does not check array bounds
  * Many Unix/Linux/C functions don't check argument sizes
  * Allows overflowing (writing past the end) of buffers (arrays)
 
* Buffer overflows on the stack can overwrite "interesting" data
  * Attackers justchoose the right inputs

* Simplest form (sometimes called "stack smashing")
  * Unchecled length on string input into bounded array causes overwriting of stack data
  * Try to change the return address of the current procedure
